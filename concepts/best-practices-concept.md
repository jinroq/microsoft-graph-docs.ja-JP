---
title: Microsoft Graph の操作に関するベスト プラクティス
description: この記事では、アプリケーションで Microsoft Graph を最大限に活用するのに役立つベスト プラクティスについて説明します。これには、Microsoft Graph の概要、アプリのパフォーマンス向上、エンドユーザーに対してアプリケーションの信頼性を高める方法が含まれます。
localization_priority: Priority
ms.openlocfilehash: 50b5149708a342b08e953790aa1b40c9335c418c
ms.sourcegitcommit: 9cee9d8229fc84dd7ef97670ff27c145e1a78408
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/18/2019
ms.locfileid: "35778682"
---
# <a name="best-practices-for-working-with-microsoft-graph"></a>Microsoft Graph の操作に関するベスト プラクティス

この記事では、アプリケーションで Microsoft Graph を最大限に活用するのに役立つベスト プラクティスについて説明します。これには、Microsoft Graph の概要、アプリのパフォーマンス向上、エンドユーザーに対してアプリケーションの信頼性を高める方法が含まれます。

## <a name="use-graph-explorer-to-get-to-know-the-api"></a>Graph エクスプローラーを使用して API を理解する

Microsoft Graph で利用できるデータについての理解を深める最も良い方法は、[Graph エクスプローラー](https://aka.ms/ge)を使用してみることです。 Graph エクスプローラーを使用すると、CRUD をすべてサポートした REST 要求を作成し、HTTP 要求ヘッダーを適合させて、データ応答を確認できます。 Graph エクスプローラーには、作業の開始に役立つ一連のサンプル クエリが用意されています。

新しい API をアプリケーションに統合する前に、それらを試してみてください。

## <a name="authentication"></a>認証

Microsoft Graph のデータにアクセスするには、アプリケーションが OAuth 2.0 アクセス トークンを取得し、次のいずれかの方法でそれを Microsoft Graph に提示する必要があります。

- HTTP *Authorization* 要求ヘッダー (*Bearer* トークンとして)
- グラフ クライアント コンストラクター (Microsoft Graph クライアント ライブラリを使用する場合)

Microsoft Authentication Library API ([MSAL](https://docs.microsoft.com/ja-JP/azure/active-directory/develop/active-directory-v2-libraries)) を使用して、Microsoft Graph へのアクセス トークンを取得します。

## <a name="consent-and-authorization"></a>同意と承認

アプリで同意と承認を行うには、次のベスト プラクティスを適用します。

- **最小限の権限を使用する**。 絶対に必要なアクセス許可のみを、本当に必要な場合に限って要求します。 アプリケーションが呼び出す API の場合、メソッドに関するトピックの「アクセス許可」セクションを確認し (例として「[ユーザーを作成する](/graph/api/user-post-users?view=graph-rest-1.0)」をご覧ください)、必要最小限の権限が付与されたアクセス許可を選択します。 アクセス許可の完全な一覧については、「[アクセス許可のリファレンス](permissions-reference.md)」をご覧ください。

- **シナリオに応じて適切なアクセス許可の種類を使用する**。 サインインしているユーザーが存在している対話型のアプリケーションを作成する場合、そのアプリケーションは*委任された*アクセス許可を使用する必要があります。これにより、アプリケーションはアクセス許可を委任され、Microsoft Graph に呼び出しを行う際にサインインしているユーザーとして動作します。 ただし、バックグラウンド サービスまたはデーモンなど、サインインしているユーザーなしで動作するアプリケーションの場合は、アプリケーションのアクセス許可を使用する必要があります。

    >**注:** アプリケーションのアクセス許可を対話型のシナリオで使用すると、アプリケーションがコンプライアンスやセキュリティ上のリスクにさらされる恐れがあります。 これにより、ユーザーの権限を誤って昇格させ、管理者によって設定されたポリシーを回避してデータにアクセスできるようにしてしまう可能性があります。
<!-- LG: Use a more clear lead-in here, like "Consider the end user and admin experience"? -->
- **慎重にアプリを構成する**。 これは、エンドユーザーや管理者のエクスペリエンス、およびアプリケーションの導入とセキュリティに直接影響します。 例:

  - アプリケーションのプライバシーに関する声明、使用条件、名前、ロゴ、ドメインは、同意その他の操作で表示されるので、エンドユーザーが理解できるように慎重に構成する必要があります。
  - アプリケーションに同意するのがどのようなユーザーなのか (エンドユーザーか管理者か) を考慮した上で、アプリケーションが[適切なアクセス許可を要求する](https://docs.microsoft.com/ja-JP/azure/active-directory/develop/active-directory-v2-scopes)ように構成します。
  - [静的、動的、増分同意](https://docs.microsoft.com/ja-JP/azure/active-directory/develop/active-directory-v2-compare#incremental-and-dynamic-consent)の違いを確実に理解している必要があります。

- **マルチテナント アプリケーションを考慮する**。 ユーザーによって、アプリケーションや同意のコントロールはまちまちで、その状態もさまざまであることを想定します。 例:

  - テナント管理者は、エンドユーザーがアプリケーションに同意する機能を無効にできます。 この例では、管理者がユーザーに代わって同意する必要があります。
  - テナント管理者は、ユーザーが他のユーザーのプロファイルを読み取れないようにする場合や、セルフ サービスのグループ作成を限られたユーザーのみに限定する場合のように、カスタム承認ポリシーを設定できます。 この例では、アプリケーションがあるユーザーの代理として動作している場合、そのアプリケーションが 403 エラー応答を処理することを想定する必要があります。

## <a name="handle-responses-effectively"></a>応答を効果的に処理する

Microsoft Graph に対して行う要求に応じて、アプリケーションがさまざまな種類の応答を処理できるようにしておく必要があります。 エンドユーザーがアプリケーションの動作を信頼し予測できるようにするために従う必要のある、最も重要なプラクティスの一部を次に示します。

### <a name="pagination"></a>改ページ

リソース コレクションのクエリを実行する場合、Microsoft Graph が返す結果セットは、サーバー側のページ サイズ制限が原因で複数ページになることを想定する必要があります。 要求セットが複数ページにまたがる場合、Microsoft Graph は、結果の次ページへの URL を格納する `@odata.nextLink` プロパティを応答で返します。

たとえば、サインインしているユーザーを一覧表示する次のようなメッセージの場合、

```http
GET https://graph.microsoft.com/v1.0/me/messages
```

結果セットがサーバー側のページ サイズ制限を超えると、`@odata.nextLink` プロパティを格納した応答が返されます。

```json
"@odata.nextLink": "https://graph.microsoft.com/v1.0/me/messages?$skip=23"
```

>**注:** 作成するアプリケーションは、応答が実際にページングされている可能性を**常に**考慮し、結果の次ページのセットを取得する `@odata.nextLink` プロパティを使用して、結果セットのページを最後まですべて読み取るようにする必要があります。 最後のページには、`@odata.nextLink` プロパティが含まれません。 結果の次ページを要求する際は、その URL 全体を符号化文字列として処理して `@odata:nextLink` プロパティに格納する必要があります。

詳しくは、「[ページング](paging.md)」をご覧ください。

### <a name="handling-expected-errors"></a>予想されるエラーの処理

アプリケーションはすべてのエラー応答 (400 および 500 の範囲) を処理する必要がありますが、次の表に示す、予想される特定のエラーと応答に特に注意を払う必要があります。

| トピック   | HTTP エラー コード    | ベスト プラクティス|
|:-----------|:--------|:----------|
| ユーザーにアクセス権がありません | 403 | アプリケーションが起動して実行している場合、同意エクスペリエンスで必要なアクセス許可を与えられていても、このエラーが発生することがあります。  この場合、最も考えられるのは、要求されたリソースにアクセスする権限を、サインインしているユーザーが持っていないことです。 アプリケーションは、サインインしているそのユーザーに、汎用の「アクセスが拒否されました」というエラーを返す必要があります。 |
|見つかりません| 404 | 場合によっては、要求されたリソースが検出できないことがあります。 たとえば、リソースが存在しない、プロビジョニングが済んでいない (ユーザーの写真など)、削除されているなどのケースが考えられます。 削除された一部のリソース (ユーザー、グループ、アプリケーション リソースなど) は、削除から 30 日以内であれば完全に復元される*可能性*があるため、アプリケーションはこの点も考慮に入れる必要があります。|
|スロットル|429|API は、さまざまな理由から常にスロットルと呼ばれる状態になる可能性があります。このため、アプリケーションは**常に** 429 応答を処理できるようにしておく必要があります。 このエラー応答には、*Retry-After* フィールドが HTTP 応答ヘッダーに格納されています。 *Retry-After* の延期期間を使用して要求を一旦取り消すことが、最も迅速にスロットルを解消する方法です。 詳細については、「[スロットル](throttling.md)」をご覧ください。|
|サービスを使用できません| 503 | サービスが使用中の可能性があります。 429 と同様に、要求を一旦取り消す方法を採用する必要があります。 さらに、新しい HTTP 接続経由で再試行要求を新たに作成することが**常に**必要です。|

### <a name="evolvable-enums"></a>Evolvable 列挙型

クライアント アプリケーションは、既存の列挙型にメンバーを追加することで分割される場合があります。 Microsoft Graph の新しい列挙型の一部では、重大な変更を加えずに新規メンバーを追加できるようにするメカニズムが用意されています。 これらの新しい列挙型では、`unknownFutureValue` と呼ばれる共通の*標識*メンバーにより、既知の列挙型メンバーと不明な列挙型メンバーが区別されます。 既知のメンバーにはこの標識メンバーより小さい値が指定され、不明なメンバーには大きな値が指定されます。
既定では、Microsoft Graph は不明なメンバーを返しません。 アプリケーションが不明なメンバーを処理するように作成されている場合、HTTP *Prefer* 要求ヘッダーを使用して不明な列挙型メンバーを受け取るようにオプトインできます。

>**注:** アプリケーションが不明なメンバーを処理できるようになっている場合、次のように HTTP *prefer* 要求ヘッダーを使用してオプトインする必要があります。`Prefer: include-unknown-enum-members`。


## <a name="storing-data-locally"></a>ローカルにデータを保存する

アプリケーションは、Microsoft Graph に対して呼び出しを実行し、必要に応じてリアルタイムでデータを取得するのが理想的です。 特定のシナリオに必要な場合に限って、データをローカルにキャッシュし保存するようにします。そのようなユース ケースが使用条件やプライバシー ポリシーの対象となっている場合は、「[Microsoft API の利用規約](/legal/microsoft-apis/terms-of-use?context=/graph/context)」に違反しないようにする必要があります。 適切な保持ポリシーと削除ポリシーをアプリケーションに実装する必要もあります。

## <a name="optimizations"></a>最適化

一般に、パフォーマンス、セキュリティ、プライバシー保護などの理由から、アプリケーションが本当に必要とするデータのみを取得するようにする必要があります。

### <a name="use-projections"></a>使用予測

アプリケーションで本当に必要となるプロパティのみを選択します。これにより、不要なネットワーク トラフィックだけでなく、アプリケーション (やサービス) での不要なデータ処理を削減できます。

>**注:** クエリから返されるプロパティをアプリケーションで必要なものだけに制限するには、`$select` クエリ パラメーターを使用します。

たとえば、サインイン ユーザーのメッセージを取得するとき、**from** プロパティと **subject** プロパティだけを返すよう指定できます。

```http
GET https://graph.microsoft.com/v1.0/me/messages?$select=from,subject
```

### <a name="getting-minimal-responses"></a>最低限の応答を取得する

PUT、PATCH (および一部の POST) などのいくつかの操作では、アプリケーションで応答ペイロードを利用する必要がない場合、API が最低限のデータを返すようにできます。 一部のサービスでは、PUT 操作や PATCH 操作に対して既に「204 No Content」応答が返されています。

>**注:** 適切な場合は、HTTP 要求ヘッダーを次のように使用して、最低限の表示応答を要求します。*Prefer: return=minimal*。 ただし、作成操作ではこの処理が不適切な場合があることにご注意ください。これは、新しく作成されたオブジェクトに対してサービスで生成された `id` を、アプリケーションが応答で取得する可能性が想定されるためです。

### <a name="track-changes-delta-query-and-webhook-notifications"></a>変更履歴の記録: デルタ クエリと webhook 通知

アプリケーションでデータへの変更を認識する必要がある場合、対象データが変更されるたびに webhook 通知を取得できます。 この方が、定期的にポーリングするよりも効率的です。

データが変更されたときにプッシュ通知を取得するには、[webhook 通知](/graph/api/resources/webhooks?view=graph-rest-1.0)を使用します。

アプリケーションで Microsoft Graph データをローカルにキャッシュまたは保存し、そのデータを常に最新の状態に保ったり、何らかの理由でデータへの変更履歴を記録したりする必要がある場合は、デルタ クエリを使用する必要があります。 これにより、アプリケーションが既に持っているデータを取得するために過剰な計算を行う必要がなくなり、ネットワーク トラフィックを最小化し、スロットルのしきい値に到達しにくくできます。

効率よくデータを最新の状態に保つには、[デルタ クエリ](delta-query-overview.md)を使用します。

### <a name="using-webhooks-and-delta-query-together"></a>webhook とデルタ クエリを組み合わせて使用する

多くの場合、webhook とデルタ クエリを組み合わせて使用する方がさらに優れています。デルタ クエリのみを使用する場合、適切なポーリング間隔を見つける必要がありますが、間隔が短すぎると空の応答が返されてリソースが浪費され、逆に間隔が長すぎるとデータが古くなりすぎる可能性があります。 webhook 通知をデルタ クエリ呼び出しを実行するトリガーとして使うと、最適な結果が得られます。

[webhook 通知](/graph/api/resources/webhooks?view=graph-rest-1.0)を、デルタ クエリ呼び出しを実行するトリガーとして使用します。 通知がトリガーされない場合に備えて、バックストップ ポーリングしきい値をアプリケーションに指定しておく必要もあります。

### <a name="batching"></a>バッチ処理

JSON のバッチ処理を使用すると、複数の要求を単一の JSON オブジェクトに統合することにより、アプリケーションを最適化することができます。 それぞれの要求を 1 つのバッチ要求にまとめることで、アプリケーションのネットワーク待機時間を大きく削減し、接続リソースを節約することができます。

大幅なネットワーク待機時間がパフォーマンスに大きな影響を及ぼす可能性がある場合、[バッチ処理](json-batching.md)を使用します。

## <a name="reliability-and-support"></a>信頼性とサポート
アプリケーションの信頼性を確保しサポートを容易にするには、次のようにします。

- DNS TTL を優先し、接続 TTL をそれに合わせて設定します。 これにより、フェールオーバーの際の可用性を確保できます。
- アドバタイズされたすべての DNS 応答に対して接続を開きます。
- 一意の GUID を生成し、Microsoft Graph Rest 要求ごとに送信します。 ユーザーが Microsoft Graph に関する問題を報告する必要がある場合、このようにすると、Microsoft はエラーを容易に調査できるようになります。
  - Microsoft Graph への要求ごとに一意の GUID が生成され、その GUID は `client-request-id` HTTP 要求ヘッダー内に送信され、アプリケーションのログにも記録されます。
  - HTTP 応答ヘッダーからの `request-id`、`timestamp`、および `x-ms-ags-diagnostic` は、常に記録されます。 これらは、`client-request-id` と共に、[Stack Overflow](https://stackoverflow.com/questions/tagged/microsoft-graph) または Microsoft サポートに問題を報告する際に必要です。
